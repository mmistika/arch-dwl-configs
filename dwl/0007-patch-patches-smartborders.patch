From 9c21770bc1aed8d638495bfad26ffc69e711e40e Mon Sep 17 00:00:00 2001
From: mmistika <mistikasoft@gmail.com>
Date: Tue, 24 Jun 2025 21:48:39 +0200
Subject: [PATCH 07/14] patch: patches/smartborders

---
 config.def.h                 |   1 +
 dwl.c                        |  47 +++++---
 patches/smartborders07.patch | 204 +++++++++++++++++++++++++++++++++++
 3 files changed, 236 insertions(+), 16 deletions(-)
 create mode 100644 patches/smartborders07.patch

diff --git a/config.def.h b/config.def.h
index 56e0823..b373e97 100644
--- a/config.def.h
+++ b/config.def.h
@@ -6,6 +6,7 @@
 /* appearance */
 static const int sloppyfocus               = 1;  /* focus follows mouse */
 static const int bypass_surface_visibility = 0;  /* 1 means idle inhibitors will disable idle tracking even if it's surface isn't visible  */
+static const int smartborders              = 1;
 static const unsigned int borderpx         = 1;  /* border pixel of windows */
 static const int showbar                   = 1; /* 0 means no bar */
 static const int topbar                    = 1; /* 0 means bottom bar */
diff --git a/dwl.c b/dwl.c
index 3644e21..a2b565c 100644
--- a/dwl.c
+++ b/dwl.c
@@ -355,7 +355,7 @@ static void rendermon(struct wl_listener *listener, void *data);
 static void requestdecorationmode(struct wl_listener *listener, void *data);
 static void requeststartdrag(struct wl_listener *listener, void *data);
 static void requestmonstate(struct wl_listener *listener, void *data);
-static void resize(Client *c, struct wlr_box geo, int interact);
+static void resize(Client *c, struct wlr_box geo, int interact, int draw_borders);
 static void run(char *startup_cmd);
 static void setcursor(struct wl_listener *listener, void *data);
 static void setcursorshape(struct wl_listener *listener, void *data);
@@ -922,7 +922,7 @@ closemon(Monitor *m)
 	wl_list_for_each(c, &clients, link) {
 		if (c->isfloating && c->geom.x > m->m.width)
 			resize(c, (struct wlr_box){.x = c->geom.x - m->w.width, .y = c->geom.y,
-					.width = c->geom.width, .height = c->geom.height}, 0);
+					.width = c->geom.width, .height = c->geom.height}, 0, 1);
 		if (c->mon == m)
 			setmon(c, selmon, c->tags);
 	}
@@ -992,8 +992,11 @@ commitnotify(struct wl_listener *listener, void *data)
 		return;
 	}
 
-	if (client_surface(c)->mapped && c->mon)
-		resize(c, c->geom, (c->isfloating && !c->isfullscreen));
+	if (client_surface(c)->mapped && c->mon && c->mon->lt[c->mon->sellt]->arrange
+			&& !c->isfullscreen && !c->isfloating)
+		c->mon->lt[c->mon->sellt]->arrange(c->mon);
+	else
+		resize(c, c->geom, (c->isfloating && !c->isfullscreen), (c->isfloating && !c->isfullscreen));
 
 	/* mark a pending resize as completed */
 	if (c->resize && c->resize <= c->surface.xdg->current.configure_serial)
@@ -2115,7 +2118,7 @@ monocle(Monitor *m)
 	wl_list_for_each(c, &clients, link) {
 		if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
 			continue;
-		resize(c, m->w, 0);
+		resize(c, m->w, 0, !smartborders);
 		n++;
 	}
 	if (n)
@@ -2207,11 +2210,11 @@ motionnotify(uint32_t time, struct wlr_input_device *device, double dx, double d
 	if (cursor_mode == CurMove) {
 		/* Move the grabbed client to the new position. */
 		resize(grabc, (struct wlr_box){.x = (int)round(cursor->x) - grabcx, .y = (int)round(cursor->y) - grabcy,
-			.width = grabc->geom.width, .height = grabc->geom.height}, 1);
+			.width = grabc->geom.width, .height = grabc->geom.height}, 1, 1);
 		return;
 	} else if (cursor_mode == CurResize) {
 		resize(grabc, (struct wlr_box){.x = grabc->geom.x, .y = grabc->geom.y,
-			.width = (int)round(cursor->x) - grabc->geom.x, .height = (int)round(cursor->y) - grabc->geom.y}, 1);
+			.width = (int)round(cursor->x) - grabc->geom.x, .height = (int)round(cursor->y) - grabc->geom.y}, 1, 1);
 		return;
 	}
 
@@ -2478,7 +2481,7 @@ requestmonstate(struct wl_listener *listener, void *data)
 }
 
 void
-resize(Client *c, struct wlr_box geo, int interact)
+resize(Client *c, struct wlr_box geo, int interact, int draw_borders)
 {
 	struct wlr_box *bbox;
 	struct wlr_box clip;
@@ -2490,6 +2493,7 @@ resize(Client *c, struct wlr_box geo, int interact)
 
 	client_set_bounds(c, geo.width, geo.height);
 	c->geom = geo;
+	c->bw = draw_borders ? borderpx : 0;
 	applybounds(c, bbox);
 
 	/* Update scene-graph, including borders */
@@ -2601,6 +2605,8 @@ setfloating(Client *c, int floating)
 	wlr_scene_node_reparent(&c->scene->node, layers[c->isfullscreen ||
 			(p && p->isfullscreen) ? LyrFS
 			: c->isfloating ? LyrFloat : LyrTile]);
+	if (c->isfloating && !c->bw)
+		resize(c, c->mon->m, 0, 1);
 	arrange(c->mon);
 	drawbars();
 }
@@ -2618,11 +2624,11 @@ setfullscreen(Client *c, int fullscreen)
 
 	if (fullscreen) {
 		c->prev = c->geom;
-		resize(c, c->mon->m, 0);
+		resize(c, c->mon->m, 0, 0);
 	} else {
 		/* restore previous size instead of arrange for floating windows since
 		 * client positions are set by the user and cannot be recalculated */
-		resize(c, c->prev, 0);
+		resize(c, c->prev, 0, 1);
 	}
 	arrange(c->mon);
 	drawbars();
@@ -2649,6 +2655,12 @@ setlayout(const Arg *arg)
 	if (arg && arg->v)
 		selmon->lt[selmon->sellt] = (Layout *)arg->v;
 	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, LENGTH(selmon->ltsymbol));
+	if (!selmon->lt[selmon->sellt]->arrange) {
+		/* floating layout, draw borders around all clients */
+		Client *c;
+		wl_list_for_each(c, &clients, link)
+			resize(c, c->mon->m, 0, 1);
+	}
 	arrange(selmon);
 	drawbar(selmon);
 }
@@ -2683,7 +2695,7 @@ setmon(Client *c, Monitor *m, uint32_t newtags)
 		arrange(oldmon);
 	if (m) {
 		/* Make sure window actually overlaps with the monitor */
-		resize(c, c->geom, 0);
+		resize(c, c->geom, 0, 1);
 		c->tags = newtags ? newtags : m->tagset[m->seltags]; /* assign tags of target monitor */
 		setfullscreen(c, c->isfullscreen); /* This will call arrange(c->mon) */
 		setfloating(c, c->isfloating);
@@ -3013,7 +3025,7 @@ tagmon(const Arg *arg)
 void
 tile(Monitor *m)
 {
-	unsigned int mw, my, ty;
+	unsigned int mw, my, ty, draw_borders = 1;
 	int i, n = 0;
 	Client *c;
 
@@ -3023,6 +3035,9 @@ tile(Monitor *m)
 	if (n == 0)
 		return;
 
+	if (n == smartborders)
+		draw_borders = 0;
+
 	if (n > m->nmaster)
 		mw = m->nmaster ? (int)roundf(m->w.width * m->mfact) : 0;
 	else
@@ -3033,11 +3048,11 @@ tile(Monitor *m)
 			continue;
 		if (i < m->nmaster) {
 			resize(c, (struct wlr_box){.x = m->w.x, .y = m->w.y + my, .width = mw,
-				.height = (m->w.height - my) / (MIN(n, m->nmaster) - i)}, 0);
+				.height = (m->w.height - my) / (MIN(n, m->nmaster) - i)}, 0, draw_borders);
 			my += c->geom.height;
 		} else {
 			resize(c, (struct wlr_box){.x = m->w.x + mw, .y = m->w.y + ty,
-				.width = m->w.width - mw, .height = (m->w.height - ty) / (n - i)}, 0);
+				.width = m->w.width - mw, .height = (m->w.height - ty) / (n - i)}, 0, draw_borders);
 			ty += c->geom.height;
 		}
 		i++;
@@ -3214,7 +3229,7 @@ updatemons(struct wl_listener *listener, void *data)
 		arrange(m);
 		/* make sure fullscreen clients have the right size */
 		if ((c = focustop(m)) && c->isfullscreen)
-			resize(c, m->m, 0);
+			resize(c, m->m, 0, 0);
 
 		/* Try to re-set the gamma LUT when updating monitors,
 		 * it's only really needed when enabling a disabled output, but meh. */
@@ -3461,7 +3476,7 @@ configurex11(struct wl_listener *listener, void *data)
 	}
 	if (c->isfloating || client_is_unmanaged(c))
 		resize(c, (struct wlr_box){.x = event->x, .y = event->y,
-				.width = event->width + c->bw * 2, .height = event->height + c->bw * 2}, 0);
+				.width = event->width + c->bw * 2, .height = event->height + c->bw * 2}, 0, 1);
 	else
 		arrange(c->mon);
 }
diff --git a/patches/smartborders07.patch b/patches/smartborders07.patch
new file mode 100644
index 0000000..732f06f
--- /dev/null
+++ b/patches/smartborders07.patch
@@ -0,0 +1,204 @@
+From b10e044d95072994d9b00b31ea70051ab02a026b Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Leonardo=20Hern=C3=A1ndez=20Hern=C3=A1ndez?=
+ <leohdz172@protonmail.com>
+Date: Tue, 16 Aug 2022 15:28:00 -0500
+Subject: [PATCH] don't draw borders if there is only one window
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Co-authored-by: A Frederick Christensen <dwl@ivories.org>
+Co-authored-by: Andrey Proskurin <andreyproskurin@protonmail.com>
+Signed-off-by: Leonardo Hernández Hernández <leohdz172@proton.me>
+---
+ config.def.h |  1 +
+ dwl.c        | 47 +++++++++++++++++++++++++++++++----------------
+ 2 files changed, 32 insertions(+), 16 deletions(-)
+
+diff --git a/config.def.h b/config.def.h
+index 22d2171d..632f151f 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -6,6 +6,7 @@
+ /* appearance */
+ static const int sloppyfocus               = 1;  /* focus follows mouse */
+ static const int bypass_surface_visibility = 0;  /* 1 means idle inhibitors will disable idle tracking even if it's surface isn't visible  */
++static const int smartborders              = 1;
+ static const unsigned int borderpx         = 1;  /* border pixel of windows */
+ static const float rootcolor[]             = COLOR(0x222222ff);
+ static const float bordercolor[]           = COLOR(0x444444ff);
+diff --git a/dwl.c b/dwl.c
+index a2711f67..647ce38c 100644
+--- a/dwl.c
++++ b/dwl.c
+@@ -320,7 +320,7 @@ static void rendermon(struct wl_listener *listener, void *data);
+ static void requestdecorationmode(struct wl_listener *listener, void *data);
+ static void requeststartdrag(struct wl_listener *listener, void *data);
+ static void requestmonstate(struct wl_listener *listener, void *data);
+-static void resize(Client *c, struct wlr_box geo, int interact);
++static void resize(Client *c, struct wlr_box geo, int interact, int draw_borders);
+ static void run(char *startup_cmd);
+ static void setcursor(struct wl_listener *listener, void *data);
+ static void setcursorshape(struct wl_listener *listener, void *data);
+@@ -746,7 +746,7 @@ closemon(Monitor *m)
+ 	wl_list_for_each(c, &clients, link) {
+ 		if (c->isfloating && c->geom.x > m->m.width)
+ 			resize(c, (struct wlr_box){.x = c->geom.x - m->w.width, .y = c->geom.y,
+-					.width = c->geom.width, .height = c->geom.height}, 0);
++					.width = c->geom.width, .height = c->geom.height}, 0, 1);
+ 		if (c->mon == m)
+ 			setmon(c, selmon, c->tags);
+ 	}
+@@ -814,8 +814,11 @@ commitnotify(struct wl_listener *listener, void *data)
+ 		return;
+ 	}
+ 
+-	if (client_surface(c)->mapped && c->mon)
+-		resize(c, c->geom, (c->isfloating && !c->isfullscreen));
++	if (client_surface(c)->mapped && c->mon && c->mon->lt[c->mon->sellt]->arrange
++			&& !c->isfullscreen && !c->isfloating)
++		c->mon->lt[c->mon->sellt]->arrange(c->mon);
++	else
++		resize(c, c->geom, (c->isfloating && !c->isfullscreen), (c->isfloating && !c->isfullscreen));
+ 
+ 	/* mark a pending resize as completed */
+ 	if (c->resize && c->resize <= c->surface.xdg->current.configure_serial)
+@@ -1775,7 +1778,7 @@ monocle(Monitor *m)
+ 	wl_list_for_each(c, &clients, link) {
+ 		if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
+ 			continue;
+-		resize(c, m->w, 0);
++		resize(c, m->w, 0, !smartborders);
+ 		n++;
+ 	}
+ 	if (n)
+@@ -1867,11 +1870,11 @@ motionnotify(uint32_t time, struct wlr_input_device *device, double dx, double d
+ 	if (cursor_mode == CurMove) {
+ 		/* Move the grabbed client to the new position. */
+ 		resize(grabc, (struct wlr_box){.x = (int)round(cursor->x) - grabcx, .y = (int)round(cursor->y) - grabcy,
+-			.width = grabc->geom.width, .height = grabc->geom.height}, 1);
++			.width = grabc->geom.width, .height = grabc->geom.height}, 1, 1);
+ 		return;
+ 	} else if (cursor_mode == CurResize) {
+ 		resize(grabc, (struct wlr_box){.x = grabc->geom.x, .y = grabc->geom.y,
+-			.width = (int)round(cursor->x) - grabc->geom.x, .height = (int)round(cursor->y) - grabc->geom.y}, 1);
++			.width = (int)round(cursor->x) - grabc->geom.x, .height = (int)round(cursor->y) - grabc->geom.y}, 1, 1);
+ 		return;
+ 	}
+ 
+@@ -2178,7 +2181,7 @@ requestmonstate(struct wl_listener *listener, void *data)
+ }
+ 
+ void
+-resize(Client *c, struct wlr_box geo, int interact)
++resize(Client *c, struct wlr_box geo, int interact, int draw_borders)
+ {
+ 	struct wlr_box *bbox;
+ 	struct wlr_box clip;
+@@ -2190,6 +2193,7 @@ resize(Client *c, struct wlr_box geo, int interact)
+ 
+ 	client_set_bounds(c, geo.width, geo.height);
+ 	c->geom = geo;
++	c->bw = draw_borders ? borderpx : 0;
+ 	applybounds(c, bbox);
+ 
+ 	/* Update scene-graph, including borders */
+@@ -2314,6 +2318,8 @@ setfloating(Client *c, int floating)
+ 	wlr_scene_node_reparent(&c->scene->node, layers[c->isfullscreen ||
+ 			(p && p->isfullscreen) ? LyrFS
+ 			: c->isfloating ? LyrFloat : LyrTile]);
++	if (c->isfloating && !c->bw)
++		resize(c, c->mon->m, 0, 1);
+ 	arrange(c->mon);
+ 	printstatus();
+ }
+@@ -2331,11 +2337,11 @@ setfullscreen(Client *c, int fullscreen)
+ 
+ 	if (fullscreen) {
+ 		c->prev = c->geom;
+-		resize(c, c->mon->m, 0);
++		resize(c, c->mon->m, 0, 0);
+ 	} else {
+ 		/* restore previous size instead of arrange for floating windows since
+ 		 * client positions are set by the user and cannot be recalculated */
+-		resize(c, c->prev, 0);
++		resize(c, c->prev, 0, 1);
+ 	}
+ 	arrange(c->mon);
+ 	printstatus();
+@@ -2362,6 +2368,12 @@ setlayout(const Arg *arg)
+ 	if (arg && arg->v)
+ 		selmon->lt[selmon->sellt] = (Layout *)arg->v;
+ 	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, LENGTH(selmon->ltsymbol));
++	if (!selmon->lt[selmon->sellt]->arrange) {
++		/* floating layout, draw borders around all clients */
++		Client *c;
++		wl_list_for_each(c, &clients, link)
++			resize(c, c->mon->m, 0, 1);
++	}
+ 	arrange(selmon);
+ 	printstatus();
+ }
+@@ -2396,7 +2408,7 @@ setmon(Client *c, Monitor *m, uint32_t newtags)
+ 		arrange(oldmon);
+ 	if (m) {
+ 		/* Make sure window actually overlaps with the monitor */
+-		resize(c, c->geom, 0);
++		resize(c, c->geom, 0, 1);
+ 		c->tags = newtags ? newtags : m->tagset[m->seltags]; /* assign tags of target monitor */
+ 		setfullscreen(c, c->isfullscreen); /* This will call arrange(c->mon) */
+ 		setfloating(c, c->isfloating);
+@@ -2691,7 +2703,7 @@ tagmon(const Arg *arg)
+ void
+ tile(Monitor *m)
+ {
+-	unsigned int mw, my, ty;
++	unsigned int mw, my, ty, draw_borders = 1;
+ 	int i, n = 0;
+ 	Client *c;
+ 
+@@ -2701,6 +2713,9 @@ tile(Monitor *m)
+ 	if (n == 0)
+ 		return;
+ 
++	if (n == smartborders)
++		draw_borders = 0;
++
+ 	if (n > m->nmaster)
+ 		mw = m->nmaster ? (int)roundf(m->w.width * m->mfact) : 0;
+ 	else
+@@ -2711,11 +2726,11 @@ tile(Monitor *m)
+ 			continue;
+ 		if (i < m->nmaster) {
+ 			resize(c, (struct wlr_box){.x = m->w.x, .y = m->w.y + my, .width = mw,
+-				.height = (m->w.height - my) / (MIN(n, m->nmaster) - i)}, 0);
++				.height = (m->w.height - my) / (MIN(n, m->nmaster) - i)}, 0, draw_borders);
+ 			my += c->geom.height;
+ 		} else {
+ 			resize(c, (struct wlr_box){.x = m->w.x + mw, .y = m->w.y + ty,
+-				.width = m->w.width - mw, .height = (m->w.height - ty) / (n - i)}, 0);
++				.width = m->w.width - mw, .height = (m->w.height - ty) / (n - i)}, 0, draw_borders);
+ 			ty += c->geom.height;
+ 		}
+ 		i++;
+@@ -2884,7 +2899,7 @@ updatemons(struct wl_listener *listener, void *data)
+ 		arrange(m);
+ 		/* make sure fullscreen clients have the right size */
+ 		if ((c = focustop(m)) && c->isfullscreen)
+-			resize(c, m->m, 0);
++			resize(c, m->m, 0, 0);
+ 
+ 		/* Try to re-set the gamma LUT when updating monitors,
+ 		 * it's only really needed when enabling a disabled output, but meh. */
+@@ -3087,7 +3102,7 @@ configurex11(struct wl_listener *listener, void *data)
+ 	}
+ 	if (c->isfloating || client_is_unmanaged(c))
+ 		resize(c, (struct wlr_box){.x = event->x, .y = event->y,
+-				.width = event->width + c->bw * 2, .height = event->height + c->bw * 2}, 0);
++				.width = event->width + c->bw * 2, .height = event->height + c->bw * 2}, 0, 1);
+ 	else
+ 		arrange(c->mon);
+ }
+-- 
+2.46.0
+
-- 
2.50.0

